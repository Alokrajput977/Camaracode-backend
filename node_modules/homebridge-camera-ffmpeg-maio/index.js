var Accessory, Service, Characteristic, hap, UUIDGen;

var FFMPEG = require('./ffmpeg').FFMPEG;
var fsys = require('fs');

module.exports = function(homebridge) {
	Accessory = homebridge.platformAccessory;
	hap = homebridge.hap;
	Service = homebridge.hap.Service;
	Characteristic = homebridge.hap.Characteristic;
	UUIDGen = homebridge.hap.uuid;

	homebridge.registerPlatform("homebridge-camera-ffmpeg-maio", "Camera-ffmpeg-maio", ffmpegPlatform, true);
}

function ffmpegPlatform(log, config, api) {
	var self = this;
	self.log = log;
	self.config = config || {};

	if (api) {
		self.api = api;

		if (api.version < 2.1) {
			throw new Error("Unexpected API version.");
    		}

		self.api.on('didFinishLaunching', self.didFinishLaunching.bind(this));
	}
}

ffmpegPlatform.prototype.configureAccessory = function(accessory) {
	// Won't be invoked
}

ffmpegPlatform.prototype.didFinishLaunching = function() {
	var self = this;
	var videoProcessor = self.config.videoProcessor || 'ffmpeg';
	var interfaceName = self.config.interfaceName || '';

	if (self.config.cameras) {

		var configuredCameraAccessories = [];
		var cameras = self.config.cameras;

		cameras.forEach(function(cameraConfig) {

			// create camera accessory and its services
			var cameraName = cameraConfig.name;
			var videoConfig = cameraConfig.videoConfig;

			if (!cameraName || !videoConfig) {
				self.log("Missing parameters.");
				return;
			}

			var uuid = UUIDGen.generate(cameraName);
			var cameraAccessory = new Accessory(cameraName, uuid, hap.Accessory.Categories.CAMERA);
			var cameraAccessoryInfo = cameraAccessory.getService(Service.AccessoryInformation);

			if (cameraConfig.manufacturer) {
				cameraAccessoryInfo.setCharacteristic(Characteristic.Manufacturer, cameraConfig.manufacturer);
			}
			if (cameraConfig.model) {
				cameraAccessoryInfo.setCharacteristic(Characteristic.Model, cameraConfig.model);
			}
			if (cameraConfig.serialNumber) {
				cameraAccessoryInfo.setCharacteristic(Characteristic.SerialNumber, cameraConfig.serialNumber);
			}
			if (cameraConfig.firmwareRevision) {
				cameraAccessoryInfo.setCharacteristic(Characteristic.FirmwareRevision, cameraConfig.firmwareRevision);
			}

			cameraAccessory.context.log = self.log;

                        var cameraSource = new FFMPEG(hap, cameraConfig, self.log, videoProcessor, interfaceName);
                        cameraAccessory.configureCameraSource(cameraSource);

			if (cameraConfig.motion) {
				var motion = new Service.MotionSensor(cameraName);
				cameraAccessory.addService(motion);
			}

			configuredCameraAccessories.push(cameraAccessory);

			// create mqtt events if needed
			self.createMQTTEvents(cameraAccessory, cameraConfig);
		});

		self.api.publishCameraAccessories("Camera-ffmpeg-maio", configuredCameraAccessories);
	}
};

// check if check file exists
ffmpegPlatform.prototype._motionSwitchEnabled = function(cameraConfig) {

        var exists = false;

        if ( typeof(cameraConfig.motion_switch_check) != 'undefined' ) {
                try {
                        if (fsys.existsSync(cameraConfig.motion_switch_check)) {
                                exists = true;
                        }
                } catch(err) {
                        this.log("Unable to check file: " + err);
                }
        }

        return exists;
}

// create mqtt broker for sensor receiving
ffmpegPlatform.prototype.createMQTTEvents = function(cameraAccessory, cameraConfig) {

	if ( typeof(cameraConfig.motion_mqtt_server) == 'undefined' || typeof(cameraConfig.motion_mqtt_sensor_topic) == 'undefined' ) {
		return;
	}

	var self = this;
	var mqtt = require('mqtt');

	self.client = mqtt.connect(cameraConfig.motion_mqtt_server);

	self.client.on('connect', function () {
		self.client.subscribe(cameraConfig.motion_mqtt_sensor_topic, function (err) {
			if (err) {
				self.log("MQTT Connect Error:" + err);
				return;
			}
		});
	});


	var last_event_sent = "";

	self.client.on('message', function (topic, message) {

		// skip duplicate messages
		if ( last_event_sent == topic.toString()+"|"+message.toString() ) {
			return;
		}
		last_event_sent = topic.toString()+"|"+message.toString();

		// trigger sensors (switch enabled and always on sensors)
		if ( typeof(cameraConfig.motion_mqtt_sensor_off_msg) != 'undefined' && cameraConfig.motion_mqtt_sensor_off_msg == message.toString() ) {

			cameraAccessory.getService(Service.MotionSensor).setCharacteristic(Characteristic.MotionDetected, false);

		} else if ( typeof(cameraConfig.motion_mqtt_sensor_on_msg) != 'undefined' && cameraConfig.motion_mqtt_sensor_on_msg == message.toString() ) {

			if ( self._motionSwitchEnabled(cameraConfig) ) {
				cameraAccessory.getService(Service.MotionSensor).setCharacteristic(Characteristic.MotionDetected, true);
			}
		}
	});

};
